---
layout: post
comments: true
title: Dérangé.
---

On va continuer donc dans notre développement d'une application web. 

J'avais décidé d'utiliser `express` pour servir mon interface REST. Pas un mauvais choix :  ça semble fonctionner assez bien.
Et c'est pas compliqué outre mesure.

Mais, avant de parler des détails d'`express`, on va établir quelques règles de base pour l'interface REST. Premièrement, 
POST est utilisé pour créer des resources. On n'y passe pas de clé. Celle-ci elle est retournée par le post (ainsi que la
référence à ladite resource dans l'entête `Location`, le code 201 et la représentation complète). PUT met a jour et doit donc connaître la clé : en fait, on passe toujours la représentation 
en entier lors ce cette opération. Parallèlement, GET retourne exactement la même représentation. PUT et DELETE ne retournent
rien (avec un code HTTP de 204). On ajoutera rien à rien à la représentation pour l'instant (du genre HAL). 
On gardera ça simple, pour l'instant.  Ah oui ! Le format sera JSON.      

Revenons à nos moutons `express`. `Express` est essentiellement configuré par des _handlers_, des fonctions qui 
interceptent les `Request` et les transforment jusqu'à ce que l'on arrive au dernier handler, qui lui exécuterait 
la logique d'affaire (ou idéalement le délèguerait cette exécution) pour ensuite utiliser une `Response` pour 
retourner la representation ou l'erreur.

On peut _router_ des requêtes vers certains handlers. Voici un exemple simple :

[code](https://github.com/jpbelang/cursus/blob/ad8fa3479e52712c04e34c31b9385b02501a9893/backend/src/main/js/resources/users.ts#L72)
```typescript
export function createUserResource(manager: EntityManager) {
    const userRouter = express.Router()
    userRouter.use(createRepository(manager))
    userRouter.use(validateMessage((s) => UserMessage.fromNetwork(s)))
    userRouter
        .get('/', getUsers)
        .get("/:id", getUser)
        .post("/", createUser);
    return userRouter
}
```

Je crée donc un routeur. Par les handlers de ce routeur, j'attacherai le repository de typeorm au message (vraiment 
pas sûr que ce soit une bonne idee) et le second handler fera la validation des messages en entrée. Ce validateur 
retourne une réponse de 400 HTTP lorsque le message est invalide.

On attache le tout au moment de la création de l'application 

[code](https://github.com/jpbelang/cursus/blob/ad8fa3479e52712c04e34c31b9385b02501a9893/backend/src/main/js/application.ts#L15).
```typescript
export function createApplication(entityManager: EntityManager): Application {
    const app = express();
    app.use(bodyParser.json());
    app.use("/users", createUserResource(entityManager))
    return app;
}
```
En passant, c'est un peu bizarre d'écrire des tests unitaires pour ce type de code: on serait en fait en train de 
tester le code d'_express_. Et tout ça se teste beaucoup plus simplement avec un test d'intégration parce que tout 
passe ou échoue d'un coup sur une requête.  Les composantes de ces handlers devraient être testés correctement.   